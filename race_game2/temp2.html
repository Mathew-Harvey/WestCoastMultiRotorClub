<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARCADE DRONE RACER</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
            color: white;
        }

        #gameCanvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #timer {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2em;
            font-weight: bold;
            color: #ff0;
            text-shadow: 0 0 5px #f00, 0 0 10px #f00;
        }

        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 1.5em;
            color: #0ff;
            text-shadow: 0 0 5px #00f, 0 0 10px #00f;
        }

        #boost-meter {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #0ff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        #boost-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00f, #0ff);
            transform-origin: left;
            transform: scaleX(1);
        }

        #multiplier {
            position: absolute;
            top: 80px;
            right: 20px;
            font-size: 1.8em;
            color: #f0f;
            text-shadow: 0 0 5px #f0f, 0 0 10px #f0f;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #instructions {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #0ff;
            font-size: 1.2em;
            text-align: center;
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #f00, 0 0 20px #f00;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .key {
            display: inline-block;
            background-color: #333;
            border: 2px solid #0ff;
            border-radius: 5px;
            padding: 5px 10px;
            margin: 0 3px;
            color: #0ff;
        }

        #gamemodes {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
        }

        .gamemode-btn {
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 5px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .gamemode-btn:hover, .gamemode-btn.active {
            background-color: #0ff;
            color: #000;
        }

        .effect {
            position: absolute;
            pointer-events: none;
        }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000033, #000000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #start-screen h1 {
            font-size: 5em;
            color: #0ff;
            text-shadow: 0 0 10px #00f, 0 0 20px #00f;
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }

        #start-button {
            background-color: #f00;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 2em;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 0 20px #f00;
            transition: all 0.3s;
        }

        #start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px #f00;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1>ARCADE DRONE RACER</h1>
        <button id="start-button">START GAME</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        <div id="timer">TIME: 0.00s</div>
        <div id="speedometer">SPEED: 0 KPH</div>
        <div id="boost-meter"><div id="boost-fill"></div></div>
        <div id="multiplier">SCORE x2</div>
        <div id="message"></div>
        
        <div id="gamemodes">
            <button class="gamemode-btn active" data-mode="arcade">ARCADE</button>
            <button class="gamemode-btn" data-mode="sim">SIMULATION</button>
        </div>
        
        <div id="instructions">
            <p><span class="key">W</span> THROTTLE UP | <span class="key">S</span> THROTTLE DOWN | 
               <span class="key">A</span> TURN LEFT | <span class="key">D</span> TURN RIGHT</p>
            <p><span class="key">↑</span> FORWARD | <span class="key">↓</span> BACKWARD | 
               <span class="key">←</span> STRAFE LEFT | <span class="key">→</span> STRAFE RIGHT</p>
            <p><span class="key">SPACE</span> BOOST | <span class="key">V</span> CHANGE VIEW</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>
    
    <script>
        // Simple GLTFLoader implementation to avoid CORS
        class GLTFLoader {
            constructor() {
                this.crossOrigin = 'anonymous';
            }
            
            load(url, onLoad, onProgress, onError) {
                console.log("Creating simplified model instead of loading:", url);
                
                if (url.includes('drone')) {
                    // Create a cooler drone model with effects
                    const droneGroup = new THREE.Group();
                    
                    // Drone body - sleeker design
                    const bodyGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.7);
                    const bodyMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x222222, 
                        specular: 0x00ffff,
                        shininess: 100
                    });
                    const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    droneGroup.add(bodyMesh);
                    
                    // Canopy
                    const canopyGeometry = new THREE.SphereGeometry(0.15, 16, 8, 0, Math.PI * 2, 0, Math.PI/2);
                    const canopyMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x00FFFF, 
                        opacity: 0.7,
                        transparent: true,
                        specular: 0xFFFFFF 
                    });
                    const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                    canopy.position.set(0, 0.1, 0.1);
                    canopy.scale.set(1, 0.5, 1);
                    droneGroup.add(canopy);
                    
                    // Drone arms - X configuration
                    const armGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6);
                    const armMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFF0000,
                        emissive: 0x330000
                    });
                    
                    const positions = [
                        [0.3, 0, 0.3],   // Front right
                        [-0.3, 0, 0.3],  // Front left
                        [-0.3, 0, -0.3], // Rear left
                        [0.3, 0, -0.3]   // Rear right
                    ];
                    
                    // Add arms and rotors
                    for (let i = 0; i < 4; i++) {
                        const arm = new THREE.Mesh(armGeometry, armMaterial);
                        const pos = positions[i];
                        arm.position.set(pos[0]/2, 0, pos[2]/2);
                        
                        // Angle the arm toward the corner
                        arm.lookAt(new THREE.Vector3(pos[0], 0, pos[2]));
                        droneGroup.add(arm);
                        
                        // Rotors with emissive materials
                        const rotorGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.02, 12);
                        const rotorColor = (i % 2 === 0) ? 0x00FFFF : 0xFF00FF;
                        const rotorMaterial = new THREE.MeshPhongMaterial({ 
                            color: rotorColor,
                            emissive: rotorColor,
                            emissiveIntensity: 0.5,
                            transparent: true,
                            opacity: 0.8
                        });
                        
                        const rotor = new THREE.Mesh(rotorGeometry, rotorMaterial);
                        rotor.position.set(pos[0], 0.05, pos[2]);
                        rotor.rotation.x = Math.PI / 2;
                        
                        // Add blur effect for spinning rotors
                        const blurGeometry = new THREE.RingGeometry(0.1, 0.17, 16);
                        const blurMaterial = new THREE.MeshBasicMaterial({ 
                            color: rotorColor,
                            transparent: true, 
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        });
                        const rotorBlur = new THREE.Mesh(blurGeometry, blurMaterial);
                        rotorBlur.rotation.x = -Math.PI / 2;
                        rotor.add(rotorBlur);
                        
                        // Add the rotor to the drone
                        droneGroup.add(rotor);
                        
                        // Add LED lights at the ends of arms
                        const ledGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                        const ledMaterial = new THREE.MeshBasicMaterial({ 
                            color: rotorColor,
                            emissive: rotorColor,
                            emissiveIntensity: 1
                        });
                        const led = new THREE.Mesh(ledGeometry, ledMaterial);
                        led.position.set(pos[0], 0, pos[2]);
                        droneGroup.add(led);
                    }
                    
                    // Add bottom LED strips
                    const stripGeometry = new THREE.PlaneGeometry(0.5, 0.05);
                    const stripMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000, 
                        side: THREE.DoubleSide,
                        emissive: 0xFF0000
                    });
                    const bottomStrip = new THREE.Mesh(stripGeometry, stripMaterial);
                    bottomStrip.rotation.x = Math.PI / 2;
                    bottomStrip.position.y = -0.06;
                    droneGroup.add(bottomStrip);
                    
                    // Create boost effect (hidden initially)
                    const boostGeometry = new THREE.ConeGeometry(0.15, 1, 8);
                    const boostMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.7
                    });
                    const boostEffect = new THREE.Mesh(boostGeometry, boostMaterial);
                    boostEffect.position.set(0, 0, -0.8);
                    boostEffect.rotation.x = Math.PI;
                    boostEffect.visible = false;
                    boostEffect.name = "boostEffect";
                    droneGroup.add(boostEffect);
                    
                    const mockGLTF = {
                        scene: droneGroup,
                        animations: []
                    };
                    
                    if (onLoad) onLoad(mockGLTF);
                } else if (url.includes('track') || url.includes('scene')) {
                    // Just return an empty group for the track - we'll build the track separately
                    const trackGroup = new THREE.Group();
                    const mockGLTF = {
                        scene: trackGroup,
                        animations: []
                    };
                    if (onLoad) onLoad(mockGLTF);
                } else {
                    if (onError) onError(new Error("Unknown model URL: " + url));
                }
            }
        }

        // Game variables
        const DRONE_MODEL_URL = './assets/models/drone.gltf';
        const TRACK_MODEL_URL = './assets/models/scene.gltf';
        
        // Game states
        let gameStarted = false;
        let gameMode = "arcade"; // "arcade" or "sim"
        
        // Game mode physics presets
        const PHYSICS_PRESETS = {
            arcade: {
                DRONE_MASS: 0.3,
                MAX_SPEED: 80,
                ACCELERATION: 30,
                DECELERATION: 15,
                STRAFE_SPEED: 20,
                TURN_SPEED: 3.0,
                PITCH_SPEED: 2.5,
                ROLL_SPEED: 2.0,
                AUTO_LEVEL_STRENGTH: 10.0,
                GRAVITY: -4.0,
                MAX_TILT: Math.PI / 4, // 45 degrees
                DRIFT_FACTOR: 0.1,
                ANGULAR_DAMPING: 0.9,
                LINEAR_DAMPING: 0.1
            },
            sim: {
                DRONE_MASS: 0.5,
                MAX_SPEED: 60,
                ACCELERATION: 20,
                DECELERATION: 10,
                STRAFE_SPEED: 15,
                TURN_SPEED: 2.0,
                PITCH_SPEED: 2.0,
                ROLL_SPEED: 1.5,
                AUTO_LEVEL_STRENGTH: 3.0,
                GRAVITY: -9.81,
                MAX_TILT: Math.PI / 2.5, // ~70 degrees
                DRIFT_FACTOR: 0.3,
                ANGULAR_DAMPING: 0.7,
                LINEAR_DAMPING: 0.05
            }
        };
        
        // Current physics settings - start with arcade mode
        let PHYSICS = {...PHYSICS_PRESETS.arcade};
        
        // Boost settings
        const BOOST = {
            active: false,
            available: 1.0,  // 0.0 to 1.0
            rechargeRate: 0.2,  // per second
            drainRate: 0.4,     // per second
            speedMultiplier: 1.6,
            minToActivate: 0.2
        };
        
        // Camera settings
        let cameraMode = "first-person"; // "first-person" or "third-person"
        const CAMERA_OFFSET = new THREE.Vector3(0, 1.5, 4);
        
        // Game elements
        let scene, camera, renderer, clock, gltfLoader;
        let world, droneBody, trackBody, droneMesh;
        let gates = [];
        let checkpoints = [];
        let collectibles = [];
        let cameraFollow, thirdPersonCamera;
        
        // Control state
        let keysPressed = {};
        let droneVelocity = new THREE.Vector3();
        let isPointerLocked = false;
        
        // Race tracking
        let startTime = null;
        let raceActive = false;
        let raceFinished = false;
        let currentLap = 0;
        let nextCheckpointId = 0;
        let bestLapTime = null;
        let score = 0;
        let scoreMultiplier = 1;
        
        // Effects
        let engineSound, boostSound, checkpointSound, collectSound, crashSound;
        
        // Initialize the game
        document.getElementById('start-button').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            init();
        });
        
        // Game mode selection
        document.querySelectorAll('.gamemode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                setGameMode(mode);
                
                // Update UI
                document.querySelectorAll('.gamemode-btn').forEach(b => {
                    b.classList.remove('active');
                });
                btn.classList.add('active');
            });
        });
        
        function setGameMode(mode) {
            gameMode = mode;
            PHYSICS = {...PHYSICS_PRESETS[mode]};
            
            // Update drone physics if already created
            if (droneBody) {
                droneBody.mass = PHYSICS.DRONE_MASS;
                droneBody.updateMassProperties();
                droneBody.linearDamping = PHYSICS.LINEAR_DAMPING;
                droneBody.angularDamping = PHYSICS.ANGULAR_DAMPING;
                
                // Reset the drone position
                resetDrone();
            }
            
            // Update instructions based on game mode
            if (mode === "arcade") {
                showMessage("ARCADE MODE: EASY CONTROLS", 2000);
            } else {
                showMessage("SIMULATION MODE: MORE REALISTIC", 2000);
            }
        }
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222244);
            scene.fog = new THREE.FogExp2(0x222244, 0.005);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Third-person camera setup
            thirdPersonCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Camera follow helper (empty object)
            cameraFollow = new THREE.Object3D();
            scene.add(cameraFollow);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Utilities
            clock = new THREE.Clock();
            gltfLoader = new GLTFLoader();
            
            // Physics world setup
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, PHYSICS.GRAVITY, 0)
            });
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.allowSleep = true;
            
            // Materials
            const droneMaterial = new CANNON.Material('droneMaterial');
            const trackMaterial = new CANNON.Material('trackMaterial');
            
            const droneTrackContactMaterial = new CANNON.ContactMaterial(
                droneMaterial,
                trackMaterial,
                {
                    friction: 0.1,
                    restitution: 0.3,
                }
            );
            world.addContactMaterial(droneTrackContactMaterial);
            
            // Lighting
            setupLighting();
            
            // Load assets and setup game
            loadAssets();
            setupControls();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            gameStarted = true;
            animate();
        }
        
        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x444444, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1.0);
            directionalLight.position.set(50, 100, 20);
            directionalLight.castShadow = true;
            
            // Better shadow quality
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 10;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            
            scene.add(directionalLight);
            
            // Additional colored lights for atmosphere
            const purpleLight = new THREE.PointLight(0xAA00FF, 1, 50);
            purpleLight.position.set(10, 10, -30);
            scene.add(purpleLight);
            
            const blueLight = new THREE.PointLight(0x0088FF, 1, 50);
            blueLight.position.set(-10, 5, -60);
            scene.add(blueLight);
            
            const pinkLight = new THREE.PointLight(0xFF0088, 1, 50);
            pinkLight.position.set(20, 5, -100);
            scene.add(pinkLight);
        }
        
        function loadAssets() {
            // Load drone model
            gltfLoader.load(DRONE_MODEL_URL, (gltf) => {
                console.log("Drone loaded");
                droneMesh = gltf.scene;
                
                // Create physics body for drone
                const bodyShape = new CANNON.Box(new CANNON.Vec3(0.25, 0.08, 0.35));
                
                droneBody = new CANNON.Body({
                    mass: PHYSICS.DRONE_MASS,
                    linearDamping: PHYSICS.LINEAR_DAMPING,
                    angularDamping: PHYSICS.ANGULAR_DAMPING
                });
                
                droneBody.addShape(bodyShape);
                droneBody.position.set(0, 5, 0);
                droneBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
                
                // Add collision event
                droneBody.addEventListener("collide", handleCollision);
                
                world.addBody(droneBody);
                scene.add(droneMesh);
                
                // Add camera to drone
                droneMesh.add(camera);
                camera.position.set(0, 0.2, 0.15);
                camera.rotation.set(0, Math.PI, 0);
                
                // Setup the track and game elements
                createTrack();
                createCheckpoints();
                createCollectibles();
                
                // Ready to start
                showMessage("READY... SET... GO!", 3000);
            });
        }
        
        function createTrack() {
            // Ground
            const groundShape = new CANNON.Plane();
            trackBody = new CANNON.Body({ mass: 0 });
            trackBody.addShape(groundShape);
            trackBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(trackBody);
            
            // Stylized floor - grid with neon glow
            const gridSize = 300;
            const gridDivisions = 60;
            const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0x0088ff, 0x0044aa);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
            
            const floorGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000022,
                metalness: 0.9,
                roughness: 0.4,
                emissive: 0x000033
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create race gates
            createGates();
            
            // Add scenery elements
            createScenery();
            
            // Add some particles in the air for motion sense
            createParticles();
        }
        
        function createGates() {
            // Define gate positions and sizes
            const gateDefinitions = [
                { position: new THREE.Vector3(0, 5, -20), size: 8, rotation: 0, color: 0x00FFFF },
                { position: new THREE.Vector3(15, 7, -40), size: 7, rotation: Math.PI/4, color: 0xFF00FF },
                { position: new THREE.Vector3(-15, 9, -60), size: 7, rotation: -Math.PI/4, color: 0x00FFFF },
                { position: new THREE.Vector3(0, 11, -80), size: 8, rotation: 0, color: 0xFF00FF },
                { position: new THREE.Vector3(20, 8, -100), size: 6, rotation: Math.PI/3, color: 0x00FFFF },
                { position: new THREE.Vector3(-10, 6, -120), size: 6, rotation: -Math.PI/6, color: 0xFF00FF },
                { position: new THREE.Vector3(0, 5, -140), size: 8, rotation: 0, color: 0xFFFF00 }
            ];
            
            gates = [];
            
            gateDefinitions.forEach((gateDef, index) => {
                // Create a more visually interesting gate
                const gateGroup = new THREE.Group();
                
                // Main ring
                const ringGeometry = new THREE.TorusGeometry(gateDef.size/2, 0.5, 16, 32);
                const ringMaterial = new THREE.MeshStandardMaterial({ 
                    color: gateDef.color,
                    metalness: 0.7,
                    roughness: 0.3,
                    emissive: gateDef.color,
                    emissiveIntensity: 0.5
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.castShadow = true;
                gateGroup.add(ring);
                
                // Add glowing outer ring
                const glowGeometry = new THREE.TorusGeometry(gateDef.size/2, 0.6, 16, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: gateDef.color,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.scale.set(1.1, 1.1, 1.1);
                gateGroup.add(glow);
                
                // Add chevrons inside the gate
                const chevronWidth = gateDef.size * 0.7;
                const chevronHeight = gateDef.size * 0.2;
                const chevronGeometry = new THREE.BufferGeometry();
                
                // Create a V-shaped chevron
                const vertices = new Float32Array([
                    -chevronWidth/2, 0, 0,
                    0, -chevronHeight, 0,
                    chevronWidth/2, 0, 0
                ]);
                
                chevronGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                const chevronMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xFFFFFF,
                    linewidth: 2
                });
                
                // Add multiple chevrons
                for (let i = 0; i < 3; i++) {
                    const chevron = new THREE.Line(chevronGeometry, chevronMaterial);
                    chevron.position.z = i * 0.5;
                    gateGroup.add(chevron);
                }
                
                // Position and rotate the gate
                gateGroup.position.copy(gateDef.position);
                gateGroup.rotation.y = gateDef.rotation;
                scene.add(gateGroup);
                
                // Add physics trigger for the gate
                const gateShape = new CANNON.Sphere(0.1);  // Tiny sphere for the trigger
                const gateBody = new CANNON.Body({
                    mass: 0,
                    isTrigger: true,
                    position: new CANNON.Vec3(
                        gateDef.position.x,
                        gateDef.position.y,
                        gateDef.position.z
                    )
                });
                
                gateBody.addShape(gateShape);
                gateBody.collisionResponse = false;
                gateBody.userData = { isGate: true, gateId: index };
                world.addBody(gateBody);
                
                // Save the gate with its visual and physics components
                gates.push({
                    mesh: gateGroup,
                    body: gateBody,
                    definition: gateDef
                });
            });
        }
        
        function createCheckpoints() {
            // Create invisible checkpoint triggers along the track
            checkpoints = [];
            
            // Place checkpoints between gates
            for (let i = 0; i < gates.length; i++) {
                const currentGate = gates[i];
                const nextGate = gates[(i + 1) % gates.length];
                
                // Place a checkpoint between current and next gate
                const midPoint = new THREE.Vector3().add(currentGate.definition.position).add(nextGate.definition.position).multiplyScalar(0.5);
                
                // Add some height variation
                midPoint.y += 2 + Math.random() * 4;
                
                // Create physics trigger
                const checkpointShape = new CANNON.Sphere(5);  // Large enough to detect
                const checkpointBody = new CANNON.Body({
                    mass: 0,
                    isTrigger: true,
                    position: new CANNON.Vec3(midPoint.x, midPoint.y, midPoint.z)
                });
                
                checkpointBody.addShape(checkpointShape);
                checkpointBody.collisionResponse = false;
                checkpointBody.userData = { isCheckpoint: true, checkpointId: i };
                world.addBody(checkpointBody);
                
                // Optional: visualize checkpoints (for debugging)
                if (false) {  // Set to true to see checkpoint spheres
                    const checkpointVisual = new THREE.Mesh(
                        new THREE.SphereGeometry(5, 8, 8),
                        new THREE.MeshBasicMaterial({ 
                            color: 0xFFFF00, 
                            wireframe: true,
                            transparent: true,
                            opacity: 0.2
                        })
                    );
                    checkpointVisual.position.copy(midPoint);
                    scene.add(checkpointVisual);
                }
                
                checkpoints.push({
                    body: checkpointBody,
                    position: midPoint
                });
            }
        }
        
        function createCollectibles() {
            collectibles = [];
            
            // Create collectible items spread around the track
            const totalCollectibles = 30;
            
            for (let i = 0; i < totalCollectibles; i++) {
                // Determine position - along and around the track path
                const trackProgress = (i / totalCollectibles) * gates.length;
                const gateIndex = Math.floor(trackProgress);
                const gateProgress = trackProgress - gateIndex;
                
                const currentGate = gates[gateIndex];
                const nextGate = gates[(gateIndex + 1) % gates.length];
                
                // Interpolate between gates
                const basePosition = new THREE.Vector3()
                    .lerpVectors(
                        currentGate.definition.position,
                        nextGate.definition.position,
                        gateProgress
                    );
                
                // Add some random offset
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 5 + 2,
                    (Math.random() - 0.5) * 15
                );
                
                const position = basePosition.clone().add(offset);
                
                // Create visual representation - a glowing orb
                const collectibleGroup = new THREE.Group();
                
                // Core sphere
                const coreGeometry = new THREE.SphereGeometry(0.7, 16, 16);
                const coreMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFFAA00,
                    emissive: 0xFF8800,
                    shininess: 100
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                collectibleGroup.add(core);
                
                // Outer glow
                const glowGeometry = new THREE.SphereGeometry(1, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFDD44,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                collectibleGroup.add(glow);
                
                // Add orbiting particles
                const particleCount = 3;
                const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFAA });
                
                for (let j = 0; j < particleCount; j++) {
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    const angle = (j / particleCount) * Math.PI * 2;
                    particle.userData = { 
                        orbitRadius: 1.2,
                        orbitSpeed: 1 + Math.random(),
                        orbitAngle: angle,
                        orbitAxis: new THREE.Vector3(
                            Math.random() - 0.5,
                            Math.random() - 0.5,
                            Math.random() - 0.5
                        ).normalize()
                    };
                    collectibleGroup.add(particle);
                }
                
                // Position the collectible
                collectibleGroup.position.copy(position);
                scene.add(collectibleGroup);
                
                // Create physics trigger
                const collectibleShape = new CANNON.Sphere(1.5);
                const collectibleBody = new CANNON.Body({
                    mass: 0,
                    isTrigger: true,
                    position: new CANNON.Vec3(position.x, position.y, position.z)
                });
                
                collectibleBody.addShape(collectibleShape);
                collectibleBody.collisionResponse = false;
                collectibleBody.userData = { isCollectible: true, collectibleId: i };
                world.addBody(collectibleBody);
                
                // Save the collectible
                collectibles.push({
                    mesh: collectibleGroup,
                    body: collectibleBody,
                    collected: false,
                    value: 100
                });
            }
        }
        
        function updateCollectibles(deltaTime) {
            collectibles.forEach(collectible => {
                if (collectible.collected) return;
                
                // Make collectibles hover and rotate
                collectible.mesh.rotation.y += deltaTime * 0.5;
                collectible.mesh.position.y += Math.sin(clock.getElapsedTime() * 2) * deltaTime * 0.2;
                
                // Update orbiting particles
                collectible.mesh.children.forEach(child => {
                    if (child.userData.orbitRadius) {
                        const orbit = child.userData;
                        orbit.orbitAngle += deltaTime * orbit.orbitSpeed;
                        
                        // Calculate position on orbital path
                        const axis = orbit.orbitAxis;
                        const up = new THREE.Vector3(0, 1, 0);
                        const right = new THREE.Vector3().crossVectors(up, axis).normalize();
                        const forward = new THREE.Vector3().crossVectors(right, up).normalize();
                        
                        child.position.set(0, 0, 0)
                            .addScaledVector(right, Math.cos(orbit.orbitAngle) * orbit.orbitRadius)
                            .addScaledVector(forward, Math.sin(orbit.orbitAngle) * orbit.orbitRadius);
                    }
                });
            });
        }
        
        function createScenery() {
            // Add futuristic buildings and structures
            const buildingCount = 40;
            const cityRadius = 150;
            
            for (let i = 0; i < buildingCount; i++) {
                // Random position around the track
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * cityRadius;
                const position = new THREE.Vector3(
                    Math.cos(angle) * distance,
                    0,
                    Math.sin(angle) * distance
                );
                
                // Create a random building
                const height = 10 + Math.random() * 40;
                const width = 5 + Math.random() * 15;
                const depth = 5 + Math.random() * 15;
                
                const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                
                // Choose from neon color palette
                const colors = [0x0088ff, 0xff00aa, 0x00ffcc, 0xaa00ff];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                const buildingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.8,
                    roughness: 0.4,
                    emissive: color,
                    emissiveIntensity: 0.2
                });
                
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.copy(position);
                building.position.y = height / 2;
                building.castShadow = true;
                building.receiveShadow = true;
                
                // Randomly rotate building
                building.rotation.y = Math.random() * Math.PI * 2;
                
                scene.add(building);
                
                // Add windows
                addBuildingWindows(building, width, height, depth, color);
                
                // Some buildings get an antenna or other details
                if (Math.random() > 0.7) {
                    const antennaHeight = 5 + Math.random() * 10;
                    const antennaGeometry = new THREE.CylinderGeometry(0.2, 0.2, antennaHeight, 8);
                    const antennaMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x888888,
                        metalness: 0.9,
                        roughness: 0.3
                    });
                    
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.y = height / 2 + antennaHeight / 2;
                    building.add(antenna);
                    
                    // Add blinking light at top
                    const lightGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.y = antennaHeight / 2 + 0.5;
                    antenna.add(light);
                    
                    // Set up blinking
                    light.userData = {
                        blinkTime: Math.random() * 2,
                        blinkDuration: 0.2,
                        blinkRate: 1 + Math.random() * 2
                    };
                }
            }
            
            // Add some flying objects in the distance
            for (let i = 0; i < 15; i++) {
                const shipSize = 1 + Math.random() * 2;
                const shipGroup = new THREE.Group();
                
                // Ship body
                const bodyGeometry = new THREE.ConeGeometry(shipSize, shipSize * 4, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x333333,
                    shininess: 80,
                    specular: 0x888888
                });
                bodyGeometry.rotateX(Math.PI / 2);
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                shipGroup.add(body);
                
                // Engine glow
                const engineGeometry = new THREE.SphereGeometry(shipSize * 0.4, 8, 8);
                const engineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8
                });
                const engine = new THREE.Mesh(engineGeometry, engineMaterial);
                engine.position.z = shipSize * 2;
                shipGroup.add(engine);
                
                // Position the ship
                const radius = 200 + Math.random() * 200;
                const angle = Math.random() * Math.PI * 2;
                const height = 50 + Math.random() * 150;
                
                shipGroup.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                // Random rotation
                shipGroup.rotation.set(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * Math.PI * 2,
                    (Math.random() - 0.5) * 0.2
                );
                
                // Set up animation path
                shipGroup.userData = {
                    speed: 20 + Math.random() * 30,
                    rotationSpeed: (Math.random() - 0.5) * 0.1,
                    centerPoint: shipGroup.position.clone(),
                    radius: 20 + Math.random() * 40,
                    angle: Math.random() * Math.PI * 2,
                    verticalOffset: Math.random() * Math.PI * 2
                };
                
                scene.add(shipGroup);
            }
            
            // Create a distant skybox
            createSkybox();
        }
        
        function addBuildingWindows(building, width, height, depth, color) {
            // Window geometry
            const windowSize = 1;
            const windowGeometry = new THREE.PlaneGeometry(windowSize, windowSize);
            const windowMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                opacity: 0.8,
                transparent: true
            });
            
            // Calculate number of windows per side
            const windowsX = Math.floor(width / (windowSize * 1.5));
            const windowsY = Math.floor(height / (windowSize * 1.5));
            const windowsZ = Math.floor(depth / (windowSize * 1.5));
            
            // Add windows to each side with random pattern
            const sides = [
                { dir: new THREE.Vector3(1, 0, 0), count: { x: windowsZ, y: windowsY } },
                { dir: new THREE.Vector3(-1, 0, 0), count: { x: windowsZ, y: windowsY } },
                { dir: new THREE.Vector3(0, 0, 1), count: { x: windowsX, y: windowsY } },
                { dir: new THREE.Vector3(0, 0, -1), count: { x: windowsX, y: windowsY } }
            ];
            
            sides.forEach(side => {
                for (let x = 0; x < side.count.x; x++) {
                    for (let y = 0; y < side.count.y; y++) {
                        // Random chance to have a window
                        if (Math.random() > 0.3) {
                            const window = new THREE.Mesh(windowGeometry, windowMaterial.clone());
                            
                            // Position within building dimensions
                            const xPos = (x / (side.count.x - 1 || 1) - 0.5) * 
                                (side.dir.x === 0 ? width : depth);
                            const yPos = (y / (side.count.y - 1 || 1) - 0.5) * height;
                            
                            window.position.set(
                                xPos,
                                yPos,
                                0
                            );
                            
                            // Offset from surface
                            if (side.dir.x !== 0) {
                                window.position.x += side.dir.x * (width / 2 + 0.01);
                                window.rotation.y = Math.PI / 2;
                            } else {
                                window.position.z += side.dir.z * (depth / 2 + 0.01);
                            }
                            
                            // Randomly turn off some windows
                            if (Math.random() > 0.7) {
                                window.material.opacity = 0.2;
                                window.material.emissiveIntensity = 0.1;
                            }
                            
                            building.add(window);
                        }
                    }
                }
            });
        }
        
        function createSkybox() {
            // Create a large sphere for the skybox
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            // Invert the geometry so we see it from the inside
            skyGeometry.scale(-1, 1, 1);
            
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x000011,
                side: THREE.BackSide,
                fog: false
            });
            
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Add stars
            const starCount = 1000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            
            for (let i = 0; i < starCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 450 + Math.random() * 50;
                
                starPositions.push(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 1.5,
                transparent: true,
                opacity: 0.8,
                fog: false
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            
            // Add a subtle nebula effect
            const nebulaCount = 10;
            
            for (let i = 0; i < nebulaCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 400;
                
                const position = new THREE.Vector3(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                const size = 50 + Math.random() * 100;
                const nebulaGeometry = new THREE.SphereGeometry(size, 16, 16);
                
                // Choose a color for the nebula
                const nebulaColors = [0x0044FF, 0xFF00AA, 0x00FFFF, 0x8800FF];
                const nebulaColor = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: nebulaColor,
                    transparent: true,
                    opacity: 0.02 + Math.random() * 0.03,
                    side: THREE.BackSide,
                    fog: false
                });
                
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.copy(position);
                scene.add(nebula);
            }
        }
        
        function createParticles() {
            // Add particles in the air for motion feedback
            const particleCount = 1000;
            const positions = [];
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xFFFFFF,
                size: 0.5,
                transparent: true,
                opacity: 0.3
            });
            
            // Area around the track, plus some height
            const spawnBox = new THREE.Box3(
                new THREE.Vector3(-70, 0, -160),
                new THREE.Vector3(70, 30, 10)
            );
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    spawnBox.min.x + Math.random() * (spawnBox.max.x - spawnBox.min.x),
                    spawnBox.min.y + Math.random() * (spawnBox.max.y - spawnBox.min.y),
                    spawnBox.min.z + Math.random() * (spawnBox.max.z - spawnBox.min.z)
                );
            }
            
            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            particles.userData = { particleData: [] };
            
            // Store velocity for each particle
            for (let i = 0; i < particleCount; i++) {
                particles.userData.particleData.push({
                    velocity: new THREE.Vector3(0, 0, 0),
                    originalPosition: new THREE.Vector3(
                        positions[i * 3],
                        positions[i * 3 + 1],
                        positions[i * 3 + 2]
                    )
                });
            }
            
            scene.add(particles);
        }
        
        function updateParticles(deltaTime) {
            scene.children.forEach(child => {
                if (child instanceof THREE.Points && child.userData.particleData) {
                    const positions = child.geometry.attributes.position.array;
                    const particleData = child.userData.particleData;
                    
                    // Get drone velocity for particle movement
                    const droneWorldVel = new THREE.Vector3();
                    if (droneBody) {
                        droneWorldVel.copy(droneBody.velocity);
                    }
                    
                    for (let i = 0; i < particleData.length; i++) {
                        const index = i * 3;
                        const data = particleData[i];
                        
                        // Update position based on drone's movement (in opposite direction)
                        positions[index] -= droneWorldVel.x * deltaTime * 0.1;
                        positions[index + 1] -= droneWorldVel.y * deltaTime * 0.1;
                        positions[index + 2] -= droneWorldVel.z * deltaTime * 0.1;
                        
                        // Drift back to original position slowly
                        positions[index] += (data.originalPosition.x - positions[index]) * deltaTime * 0.1;
                        positions[index + 1] += (data.originalPosition.y - positions[index + 1]) * deltaTime * 0.1;
                        positions[index + 2] += (data.originalPosition.z - positions[index + 2]) * deltaTime * 0.1;
                        
                        // Add some gentle random movement
                        positions[index] += (Math.random() - 0.5) * deltaTime * 0.2;
                        positions[index + 1] += (Math.random() - 0.5) * deltaTime * 0.2;
                        positions[index + 2] += (Math.random() - 0.5) * deltaTime * 0.2;
                        
                        // Reposition particles that get too far away
                        const distance = Math.sqrt(
                            Math.pow(positions[index] - data.originalPosition.x, 2) +
                            Math.pow(positions[index + 1] - data.originalPosition.y, 2) +
                            Math.pow(positions[index + 2] - data.originalPosition.z, 2)
                        );
                        
                        if (distance > 30) {
                            positions[index] = data.originalPosition.x;
                            positions[index + 1] = data.originalPosition.y;
                            positions[index + 2] = data.originalPosition.z;
                        }
                    }
                    
                    child.geometry.attributes.position.needsUpdate = true;
                }
            });
        }
        
        function setupControls() {
            document.addEventListener('keydown', (event) => {
                keysPressed[event.code] = true;
                
                // Camera toggle
                if (event.code === 'KeyV' && !event.repeat) {
                    toggleCameraView();
                }
            });
            
            document.addEventListener('keyup', (event) => {
                keysPressed[event.code] = false;
            });
            
            document.addEventListener('click', () => {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === renderer.domElement;
            });
        }
        
        function toggleCameraView() {
            if (cameraMode === "first-person") {
                cameraMode = "third-person";
                showMessage("THIRD-PERSON VIEW", 1500);
            } else {
                cameraMode = "first-person";
                showMessage("FIRST-PERSON VIEW", 1500);
            }
        }
        
        function handleControls(deltaTime) {
            if (!droneBody) return;
            
            // Initialize acceleration
            const acceleration = new THREE.Vector3(0, 0, 0);
            let rotationY = 0;
            let wantsTilt = { pitch: 0, roll: 0 };
            
            // Get drone's forward and right directions
            const droneQuat = new THREE.Quaternion().copy(droneBody.quaternion);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(droneQuat);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(droneQuat);
            
            // Vertical movement (throttle)
            if (keysPressed['KeyW']) {
                acceleration.y += PHYSICS.ACCELERATION;
            }
            if (keysPressed['KeyS']) {
                acceleration.y -= PHYSICS.DECELERATION;
            }
            
            // Forward/backward
            if (keysPressed['ArrowUp']) {
                acceleration.addScaledVector(forward, PHYSICS.ACCELERATION);
                wantsTilt.pitch = -1; // Tilt forward
            }
            if (keysPressed['ArrowDown']) {
                acceleration.addScaledVector(forward, -PHYSICS.DECELERATION);
                wantsTilt.pitch = 1; // Tilt backward
            }
            
            // Left/right strafing
            if (keysPressed['ArrowLeft']) {
                acceleration.addScaledVector(right, -PHYSICS.STRAFE_SPEED);
                wantsTilt.roll = -1; // Roll left
            }
            if (keysPressed['ArrowRight']) {
                acceleration.addScaledVector(right, PHYSICS.STRAFE_SPEED);
                wantsTilt.roll = 1; // Roll right
            }
            
            // Turning (yaw)
            if (keysPressed['KeyA']) {
                rotationY += PHYSICS.TURN_SPEED * deltaTime;
            }
            if (keysPressed['KeyD']) {
                rotationY -= PHYSICS.TURN_SPEED * deltaTime;
            }
            
            // Boost
            handleBoost(deltaTime, keysPressed['Space']);
            
            // Apply boost multiplier if active
            if (BOOST.active) {
                acceleration.multiplyScalar(BOOST.speedMultiplier);
            }
            
            // Update drone velocity
            droneVelocity.add(acceleration.multiplyScalar(deltaTime));
            
            // Apply drift in arcade mode
            if (gameMode === "arcade") {
                // More velocity inheritance in the direction we're moving (less slip)
                const currentVel = new THREE.Vector3().copy(droneBody.velocity);
                droneVelocity.lerp(currentVel, PHYSICS.DRIFT_FACTOR);
            }
            
            // Apply speed limit
            const maxSpeed = BOOST.active ? 
                PHYSICS.MAX_SPEED * BOOST.speedMultiplier : 
                PHYSICS.MAX_SPEED;
                
            const speed = droneVelocity.length();
            if (speed > maxSpeed) {
                droneVelocity.multiplyScalar(maxSpeed / speed);
            }
            
            // Apply velocity to drone body with conversion to Cannon.js vectors
            droneBody.velocity.set(droneVelocity.x, droneVelocity.y, droneVelocity.z);
            
            // Apply rotation (yaw)
            if (rotationY !== 0) {
                const rotationQuat = new CANNON.Quaternion();
                rotationQuat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
                droneBody.quaternion = rotationQuat.mult(droneBody.quaternion);
            }
            
            // Handle tilting for arcade feel
            handleTilting(deltaTime, wantsTilt);
            
            // Update boost effect visibility
            updateBoostEffect();
            
            // Update speedometer
            document.getElementById('speedometer').innerText = 
                `SPEED: ${Math.round(speed * 3.6)} KPH`; // Convert m/s to kph
        }
        
        function handleTilting(deltaTime, wantsTilt) {
            // Get current orientation
            const currentQuat = new THREE.Quaternion().copy(droneBody.quaternion);
            
            // Auto-leveling - gradually return to level when no input
            if (Math.abs(wantsTilt.pitch) < 0.1 && Math.abs(wantsTilt.roll) < 0.1) {
                // Convert quaternion to Euler angles
                const euler = new THREE.Euler().setFromQuaternion(currentQuat);
                
                // Gradually reduce pitch and roll to zero (auto-level)
                // Note: euler.x is pitch, euler.z is roll in Three.js
                euler.x -= euler.x * PHYSICS.AUTO_LEVEL_STRENGTH * deltaTime;
                euler.z -= euler.z * PHYSICS.AUTO_LEVEL_STRENGTH * deltaTime;
                
                // Convert back to quaternion
                const targetQuat = new THREE.Quaternion().setFromEuler(euler);
                
                // Apply smoother transition
                currentQuat.slerp(targetQuat, 0.1);
                droneBody.quaternion.copy(currentQuat);
            } else {
                // Apply desired tilt
                if (Math.abs(wantsTilt.pitch) > 0.1) {
                    // Pitch (rotation around X-axis)
                    const pitchQuat = new CANNON.Quaternion();
                    pitchQuat.setFromAxisAngle(
                        new CANNON.Vec3(1, 0, 0), 
                        wantsTilt.pitch * PHYSICS.PITCH_SPEED * deltaTime
                    );
                    droneBody.quaternion = droneBody.quaternion.mult(pitchQuat);
                }
                
                if (Math.abs(wantsTilt.roll) > 0.1) {
                    // Roll (rotation around Z-axis)
                    const rollQuat = new CANNON.Quaternion();
                    rollQuat.setFromAxisAngle(
                        new CANNON.Vec3(0, 0, 1), 
                        wantsTilt.roll * PHYSICS.ROLL_SPEED * deltaTime
                    );
                    droneBody.quaternion = droneBody.quaternion.mult(rollQuat);
                }
                
                // Limit maximum tilt angle
                const euler = new THREE.Euler().setFromQuaternion(new THREE.Quaternion().copy(droneBody.quaternion));
                
                let changed = false;
                // Limit pitch
                if (Math.abs(euler.x) > PHYSICS.MAX_TILT) {
                    euler.x = Math.sign(euler.x) * PHYSICS.MAX_TILT;
                    changed = true;
                }
                
                // Limit roll
                if (Math.abs(euler.z) > PHYSICS.MAX_TILT) {
                    euler.z = Math.sign(euler.z) * PHYSICS.MAX_TILT;
                    changed = true;
                }
                
                if (changed) {
                    const cappedQuat = new THREE.Quaternion().setFromEuler(euler);
                    droneBody.quaternion.copy(cappedQuat);
                }
            }
        }
        
        function handleBoost(deltaTime, boostKeyPressed) {
            // Boost meter element
            const boostFill = document.getElementById('boost-fill');
            
            // Regenerate boost when not using it
            if (!boostKeyPressed) {
                if (BOOST.active) {
                    BOOST.active = false;
                }
                
                // Recharge boost
                BOOST.available = Math.min(1.0, BOOST.available + BOOST.rechargeRate * deltaTime);
            } else if (BOOST.available > BOOST.minToActivate) {
                // Activate boost if we have enough
                BOOST.active = true;
                BOOST.available = Math.max(0, BOOST.available - BOOST.drainRate * deltaTime);
                
                // Play boost sound effect
                // TODO: Add sound effects
            } else {
                // Not enough boost
                BOOST.active = false;
            }
            
            // Update boost meter visual
            boostFill.style.transform = `scaleX(${BOOST.available})`;
            
            // Color based on amount
            if (BOOST.available < 0.3) {
                boostFill.style.background = "linear-gradient(90deg, #f00, #f80)";
            } else {
                boostFill.style.background = "linear-gradient(90deg, #00f, #0ff)";
            }
        }
        
        function updateBoostEffect() {
            if (!droneMesh) return;
            
            // Find the boost effect
            const boostEffect = droneMesh.getObjectByName("boostEffect");
            if (boostEffect) {
                boostEffect.visible = BOOST.active;
                
                if (BOOST.active) {
                    // Animate the boost effect
                    const time = clock.getElapsedTime();
                    boostEffect.scale.set(
                        1 + Math.sin(time * 10) * 0.1,
                        1 + Math.cos(time * 15) * 0.1,
                        1 + Math.sin(time * 5) * 0.2
                    );
                    
                    // Create particle trail effect
                    if (Math.random() > 0.7) {
                        createBoostParticle();
                    }
                }
            }
        }
        
        function createBoostParticle() {
            if (!droneMesh) return;
            
            // Create particle at boost position
            const boostEffect = droneMesh.getObjectByName("boostEffect");
            if (!boostEffect) return;
            
            const worldPos = new THREE.Vector3();
            boostEffect.getWorldPosition(worldPos);
            
            // Create particle
            const particle = document.createElement('div');
            particle.className = 'effect';
            particle.style.left = '50%';
            particle.style.top = '50%';
            particle.style.width = '10px';
            particle.style.height = '10px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = Math.random() > 0.5 ? '#0ff' : '#88f';
            particle.style.opacity = '0.8';
            
            document.getElementById('hud').appendChild(particle);
            
            // Convert 3D position to screen coordinates
            const vector = worldPos.clone();
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            
            // Position particle
            particle.style.transform = `translate(${x - 5}px, ${y - 5}px)`;
            
            // Animate and remove
            setTimeout(() => {
                particle.style.transition = 'all 0.5s ease-out';
                particle.style.opacity = '0';
                particle.style.width = '20px';
                particle.style.height = '20px';
                particle.style.transform = `translate(${x - 10}px, ${y - 10}px)`;
                
                setTimeout(() => {
                    particle.remove();
                }, 500);
            }, 10);
        }
        
        function handleCollision(event) {
            if (!droneBody || raceFinished) return;
            
            const impactVelocity = event.contact.getImpactVelocityAlongNormal();
            
            // If it's a significant collision
            if (Math.abs(impactVelocity) > 5) {
                // Reduce the impact for arcade mode - less bouncy physics
                if (gameMode === "arcade") {
                    droneBody.velocity.scale(0.7, droneBody.velocity);
                }
                
                // Create impact effect
                createImpactEffect(impactVelocity);
                
                // Screen shake
                if (Math.abs(impactVelocity) > 10) {
                    shakeCamera(Math.min(Math.abs(impactVelocity) * 0.01, 0.2));
                }
                
                // Play crash sound
                // TODO: Add sound effect
            }
            
            // Check if collision is with a gate
            if (event.body.userData && event.body.userData.isGate) {
                handleGateCollision(event.body.userData.gateId);
            }
            
            // Check if collision is with a checkpoint
            if (event.body.userData && event.body.userData.isCheckpoint) {
                handleCheckpointCollision(event.body.userData.checkpointId);
            }
            
            // Check if collision is with a collectible
            if (event.body.userData && event.body.userData.isCollectible) {
                handleCollectibleCollision(event.body.userData.collectibleId);
            }
        }
        
        function createImpactEffect(impactVelocity) {
            // Create visual impact effect at drone position
            const impactSize = Math.min(Math.abs(impactVelocity) * 0.5, 30);
            
            // Get screen position of drone
            const vector = new THREE.Vector3();
            droneMesh.getWorldPosition(vector);
            vector.project(camera);
            
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
            
            // Create impact element
            const impact = document.createElement('div');
            impact.className = 'effect';
            impact.style.left = '50%';
            impact.style.top = '50%';
            impact.style.width = '10px';
            impact.style.height = '10px';
            impact.style.borderRadius = '50%';
            impact.style.backgroundColor = '#fff';
            impact.style.boxShadow = '0 0 10px #fff, 0 0 20px #0ff';
            impact.style.transform = `translate(${x - 5}px, ${y - 5}px)`;
            
            document.getElementById('hud').appendChild(impact);
            
            // Animate impact
            setTimeout(() => {
                impact.style.transition = 'all 0.3s ease-out';
                impact.style.width = `${impactSize}px`;
                impact.style.height = `${impactSize}px`;
                impact.style.opacity = '0';
                impact.style.transform = `translate(${x - impactSize/2}px, ${y - impactSize/2}px)`;
                
                setTimeout(() => {
                    impact.remove();
                }, 300);
            }, 10);
        }
        
        function shakeCamera(intensity) {
            // Apply screen shake
            let shakeDuration = 0.3;  // seconds
            let shakeStartTime = clock.getElapsedTime();
            
            function applyShake() {
                const elapsed = clock.getElapsedTime() - shakeStartTime;
                if (elapsed < shakeDuration) {
                    const shakeAmount = intensity * (1 - elapsed / shakeDuration);
                    
                    // Apply shake to camera
                    if (cameraMode === "first-person") {
                        camera.position.x += (Math.random() - 0.5) * shakeAmount;
                        camera.position.y += (Math.random() - 0.5) * shakeAmount;
                        camera.position.z += (Math.random() - 0.5) * shakeAmount;
                    } else {
                        // For third person, shake the third person camera
                        thirdPersonCamera.position.x += (Math.random() - 0.5) * shakeAmount;
                        thirdPersonCamera.position.y += (Math.random() - 0.5) * shakeAmount;
                        thirdPersonCamera.position.z += (Math.random() - 0.5) * shakeAmount;
                    }
                    
                    requestAnimationFrame(applyShake);
                }
            }
            
            applyShake();
        }
        
        function handleGateCollision(gateId) {
            // Get the gate
            const gate = gates[gateId];
            if (!gate || nextCheckpointId !== 0) return;
            
            // Mark the race as started
            if (!raceActive && !raceFinished) {
                startTime = clock.getElapsedTime();
                raceActive = true;
                showMessage("GO! GO! GO!", 2000);
            }
            
            // Update next checkpoint
            nextCheckpointId = 0;
            
            // Increment lap if we passed through the first gate
            if (gateId === 0 && raceActive) {
                currentLap++;
                showMessage(`LAP ${currentLap}`, 1500);
                
                // Handle lap timing
                const lapTime = clock.getElapsedTime() - startTime;
                if (bestLapTime === null || lapTime < bestLapTime) {
                    bestLapTime = lapTime;
                    showMessage(`NEW BEST LAP: ${bestLapTime.toFixed(2)}s`, 2000);
                }
                
                // Reset the timer for the new lap
                startTime = clock.getElapsedTime();
            }
            
            // Create visual effect
            createGateEffect(gate);
        }
        
        function handleCheckpointCollision(checkpointId) {
            if (checkpointId !== nextCheckpointId) return;
            
            // Update next checkpoint
            nextCheckpointId = (nextCheckpointId + 1) % checkpoints.length;
            
            // Add time bonus and show message
            showMessage("+2 SECONDS", 1000);
            startTime += 2;  // Add 2 seconds to the timer
            
            // Create checkpoint effect
            const checkpoint = checkpoints[checkpointId];
            createCheckpointEffect(checkpoint);
        }
        
        function handleCollectibleCollision(collectibleId) {
            // Get the collectible
            const collectible = collectibles[collectibleId];
            function handleCollectibleCollision(collectibleId) {
        // Get the collectible
        const collectible = collectibles[collectibleId];
        if (!collectible || collectible.collected) return;
        
        // Mark as collected
        collectible.collected = true;
        
        // Add score
        addScore(collectible.value);
        
        // Remove the collectible from the scene
        scene.remove(collectible.mesh);
        world.removeBody(collectible.body);
        
        // Create collectible effect
        createCollectibleEffect(collectible);
        
        // Increment multiplier
        scoreMultiplier = Math.min(scoreMultiplier + 0.1, 3.0);
        updateMultiplierDisplay();
        
        // Recharge boost a bit
        BOOST.available = Math.min(1.0, BOOST.available + 0.1);
        
        // Play collect sound
        // TODO: Add sound effect
    }
    
    function createGateEffect(gate) {
        // Flash the gate
        const originalMaterials = [];
        gate.mesh.traverse(child => {
            if (child.material) {
                originalMaterials.push({
                    object: child,
                    material: child.material.clone()
                });
                
                // Change to flash material
                child.material = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFFFF,
                    transparent: true,
                    opacity: 0.8
                });
            }
        });
        
        // Reset after a short delay
        setTimeout(() => {
            originalMaterials.forEach(item => {
                item.object.material = item.material;
            });
        }, 200);
        
        // Create screen effect
        const flash = document.createElement('div');
        flash.style.position = 'absolute';
        flash.style.top = '0';
        flash.style.left = '0';
        flash.style.width = '100%';
        flash.style.height = '100%';
        flash.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
        flash.style.pointerEvents = 'none';
        document.getElementById('hud').appendChild(flash);
        
        // Fade out the flash
        setTimeout(() => {
            flash.style.transition = 'opacity 0.3s ease-out';
            flash.style.opacity = '0';
            setTimeout(() => {
                flash.remove();
            }, 300);
        }, 50);
    }
    
    function createCheckpointEffect(checkpoint) {
        // Create floating text at checkpoint position
        const worldPos = checkpoint.position.clone();
        const screenPos = worldToScreen(worldPos);
        
        const text = document.createElement('div');
        text.className = 'effect';
        text.innerText = '+2s';
        text.style.position = 'absolute';
        text.style.left = `${screenPos.x}px`;
        text.style.top = `${screenPos.y}px`;
        text.style.color = '#0F0';
        text.style.fontSize = '2em';
        text.style.fontWeight = 'bold';
        text.style.textShadow = '0 0 10px #0F0';
        document.getElementById('hud').appendChild(text);
        
        // Animate floating up and fading out
        setTimeout(() => {
            text.style.transition = 'all 1.5s ease-out';
            text.style.transform = 'translateY(-100px)';
            text.style.opacity = '0';
            
            setTimeout(() => {
                text.remove();
            }, 1500);
        }, 10);
    }
    
    function createCollectibleEffect(collectible) {
        // Create particle explosion at collectible position
        const position = collectible.mesh.position.clone();
        const screenPos = worldToScreen(position);
        
        // Create multiple particles
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'effect';
            particle.style.position = 'absolute';
            particle.style.left = `${screenPos.x}px`;
            particle.style.top = `${screenPos.y}px`;
            particle.style.width = '5px';
            particle.style.height = '5px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = '#FF0';
            document.getElementById('hud').appendChild(particle);
            
            // Random direction
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 40;
            const x = Math.cos(angle) * distance;
            const y = Math.sin(angle) * distance;
            
            // Animate
            setTimeout(() => {
                particle.style.transition = 'all 0.7s ease-out';
                particle.style.transform = `translate(${x}px, ${y}px)`;
                particle.style.opacity = '0';
                
                setTimeout(() => {
                    particle.remove();
                }, 700);
            }, 10);
        }
        
        // Create score text
        const scoreText = document.createElement('div');
        scoreText.className = 'effect';
        scoreText.innerText = `+${collectible.value * scoreMultiplier}`;
        scoreText.style.position = 'absolute';
        scoreText.style.left = `${screenPos.x}px`;
        scoreText.style.top = `${screenPos.y}px`;
        scoreText.style.color = '#FF0';
        scoreText.style.fontSize = '1.5em';
        scoreText.style.fontWeight = 'bold';
        scoreText.style.textShadow = '0 0 10px #FF0';
        document.getElementById('hud').appendChild(scoreText);
        
        // Animate score text
        setTimeout(() => {
            scoreText.style.transition = 'all 1s ease-out';
            scoreText.style.transform = 'translateY(-50px)';
            scoreText.style.opacity = '0';
            
            setTimeout(() => {
                scoreText.remove();
            }, 1000);
        }, 10);
    }
    
    function worldToScreen(position) {
        // Convert 3D world position to screen coordinates
        const vector = position.clone();
        vector.project(camera);
        
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (vector.y * -0.5 + 0.5) * window.innerHeight
        };
    }
    
    function addScore(points) {
        // Apply multiplier
        const multipliedPoints = Math.floor(points * scoreMultiplier);
        score += multipliedPoints;
        
        // Show score update
        showMessage(`SCORE: ${score}`, 1000);
    }
    
    function updateMultiplierDisplay() {
        const multiplierEl = document.getElementById('multiplier');
        multiplierEl.innerText = `SCORE x${scoreMultiplier.toFixed(1)}`;
        
        // Show temporarily
        multiplierEl.style.opacity = '1';
        clearTimeout(multiplierEl.fadeTimeout);
        
        multiplierEl.fadeTimeout = setTimeout(() => {
            multiplierEl.style.opacity = '0';
        }, 3000);
    }
    
    function showMessage(message, duration = 2000) {
        const messageEl = document.getElementById('message');
        messageEl.innerText = message;
        messageEl.style.opacity = '1';
        
        clearTimeout(messageEl.fadeTimeout);
        
        messageEl.fadeTimeout = setTimeout(() => {
            messageEl.style.opacity = '0';
        }, duration);
    }
    
    function resetDrone() {
        if (!droneBody) return;
        
        // Reset physics
        droneBody.position.set(0, 5, 0);
        droneBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI);
        droneBody.velocity.set(0, 0, 0);
        droneBody.angularVelocity.set(0, 0, 0);
        
        // Reset control variables
        droneVelocity.set(0, 0, 0);
        
        // Reset race tracking
        raceActive = false;
        raceFinished = false;
        nextCheckpointId = 0;
        startTime = null;
        
        showMessage("READY TO RACE!", 2000);
    }
    
    function updateTimer() {
        const timerElement = document.getElementById('timer');
        
        if (raceActive && !raceFinished) {
            const elapsedTime = clock.getElapsedTime() - startTime;
            timerElement.innerText = `TIME: ${elapsedTime.toFixed(2)}s`;
            
            // Color coding time - becomes red when running out of time
            if (elapsedTime > 60) {  // Example: 60 second time limit
                timerElement.style.color = '#FF0000';
                timerElement.style.textShadow = '0 0 5px #FF0000, 0 0 10px #FF0000';
            } else if (elapsedTime > 45) {
                timerElement.style.color = '#FFFF00';
                timerElement.style.textShadow = '0 0 5px #FFFF00, 0 0 10px #FFFF00';
            }
        } else if (raceFinished) {
            const finalTime = clock.getElapsedTime() - startTime;
            timerElement.innerText = `FINISH: ${finalTime.toFixed(2)}s`;
        } else {
            timerElement.innerText = 'TIME: 0.00s';
        }
    }
    
    function updateSceneryAnimation(deltaTime) {
        // Animate flying ships
        scene.children.forEach(child => {
            if (child.userData && child.userData.speed) {
                const data = child.userData;
                
                // Update position along path
                data.angle += deltaTime * data.speed * 0.01;
                
                // Calculate new position
                const radius = data.radius;
                const height = data.centerPoint.y + Math.sin(data.angle + data.verticalOffset) * 10;
                
                child.position.set(
                    data.centerPoint.x + Math.cos(data.angle) * radius,
                    height,
                    data.centerPoint.z + Math.sin(data.angle) * radius
                );
                
                // Rotate ship to face direction of travel
                const tangent = new THREE.Vector3(
                    -Math.sin(data.angle),
                    0,
                    Math.cos(data.angle)
                );
                
                const lookAt = child.position.clone().add(tangent);
                child.lookAt(lookAt);
                
                // Add some roll to banking turns
                child.rotation.z = Math.sin(data.angle) * 0.2;
                
                // Random additional rotation
                child.rotation.x += data.rotationSpeed * deltaTime;
                child.rotation.y += data.rotationSpeed * deltaTime * 0.1;
            }
            
            // Animate building lights
            if (child.userData && child.userData.blinkTime !== undefined) {
                const data = child.userData;
                data.blinkTime -= deltaTime;
                
                if (data.blinkTime <= 0) {
                    // Toggle light
                    child.visible = !child.visible;
                    
                    // Reset timer
                    data.blinkTime = child.visible ? data.blinkDuration : data.blinkRate;
                }
            }
        });
    }
    
    function updateThirdPersonCamera() {
        if (!droneBody || cameraMode !== "third-person") return;
        
        // Position the camera follow target at the drone's position
        cameraFollow.position.copy(droneBody.position);
        cameraFollow.quaternion.copy(droneBody.quaternion);
        
        // Calculate desired camera position - behind and above the drone
        const offset = CAMERA_OFFSET.clone();
        
        // When boosting, position the camera farther back
        if (BOOST.active) {
            offset.z += 2;
            offset.y += 1;
        }
        
        // Transform offset by drone's orientation
        offset.applyQuaternion(cameraFollow.quaternion);
        const targetPosition = new THREE.Vector3().addVectors(cameraFollow.position, offset);
        
        // Smoothly interpolate current camera position toward target
        thirdPersonCamera.position.lerp(targetPosition, 0.1);
        
        // Look at the drone, but slightly ahead of it
        const lookAhead = new THREE.Vector3(0, 0, -10).applyQuaternion(cameraFollow.quaternion);
        const lookTarget = new THREE.Vector3().addVectors(cameraFollow.position, lookAhead);
        thirdPersonCamera.lookAt(lookTarget);
    }
    
    function update(deltaTime) {
        if (!gameStarted) return;
        
        // Step the physics simulation
        world.step(1/60, deltaTime);
        
        // Update drone controls and physics
        handleControls(deltaTime);
        
        // Update visuals to match physics state
        if (droneMesh && droneBody) {
            droneMesh.position.copy(droneBody.position);
            droneMesh.quaternion.copy(droneBody.quaternion);
        }
        
        // Update camera
        updateThirdPersonCamera();
        
        // Update collectible animations
        updateCollectibles(deltaTime);
        
        // Update particles
        updateParticles(deltaTime);
        
        // Update scenery animations
        updateSceneryAnimation(deltaTime);
        
        // Game logic
        updateTimer();
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        const deltaTime = Math.min(clock.getDelta(), 0.1);
        update(deltaTime);
        
        // Render with the appropriate camera
        if (cameraMode === "first-person") {
            renderer.render(scene, camera);
        } else {
            renderer.render(scene, thirdPersonCamera);
        }
    }
    
    function onWindowResize() {
        // Update cameras
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        thirdPersonCamera.aspect = window.innerWidth / window.innerHeight;
        thirdPersonCamera.updateProjectionMatrix();
        
        // Update renderer
        renderer.setSize(window.innerWidth, window.innerHeight);
    }}